<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="StudySettings">
    <StudyTaskManager>
      <option name="VERSION" value="16" />
      <option name="myUserTests">
        <map />
      </option>
      <option name="course">
        <HyperskillCourse>
          <option name="authors">
            <list />
          </option>
          <option name="courseMode" value="Study" />
          <option name="customPresentableName" />
          <option name="description" value="Games can help you kill time when you’re bored. But before smartphones, people played games the classic way – with paper and pencil. Let’s recreate one such game and improve your programming skills in the process. In this project, you will code Hangman, a game where the player has to guess a word, letter by letter, in a limited number of attempts. Make a program that plays Hangman with you – and good luck with the guessing!&lt;br/&gt;&lt;br/&gt;Learn more at &lt;a href=&quot;https://hyperskill.org&quot;&gt;https://hyperskill.org/projects/69&lt;/a&gt;" />
          <option name="environment" value="" />
          <option name="id" value="0" />
          <option name="index" value="-1" />
          <option name="language" value="Python" />
          <option name="languageCode" value="en" />
          <option name="name" value="Hangman" />
          <option name="stages">
            <list>
              <HyperskillStage>
                <option name="id" value="372" />
                <option name="stepId" value="6082" />
                <option name="title" value="Hello, Hangman" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="373" />
                <option name="stepId" value="6083" />
                <option name="title" value="I want to play a game" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="374" />
                <option name="stepId" value="6084" />
                <option name="title" value="Make your choice" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="375" />
                <option name="stepId" value="6085" />
                <option name="title" value="Help is on the way" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="376" />
                <option name="stepId" value="6086" />
                <option name="title" value="Keep trying" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="377" />
                <option name="stepId" value="6087" />
                <option name="title" value="The value of life" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="378" />
                <option name="stepId" value="6088" />
                <option name="title" value="Error!" />
              </HyperskillStage>
              <HyperskillStage>
                <option name="id" value="379" />
                <option name="stepId" value="6089" />
                <option name="title" value="Menu, please" />
              </HyperskillStage>
            </list>
          </option>
          <option name="taskToTopics">
            <map>
              <entry key="0">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="333" />
                      <option name="theoryId" value="5204" />
                      <option name="title" value="Introduction to Python" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="336" />
                      <option name="theoryId" value="5208" />
                      <option name="title" value="Overview of the basic program" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="1">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="335" />
                      <option name="theoryId" value="5233" />
                      <option name="title" value="Multi-line programs" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="402" />
                      <option name="theoryId" value="5879" />
                      <option name="title" value="PEP 8" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="403" />
                      <option name="theoryId" value="6081" />
                      <option name="title" value="Comments" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="394" />
                      <option name="theoryId" value="5852" />
                      <option name="title" value="Basic data types" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="396" />
                      <option name="theoryId" value="5859" />
                      <option name="title" value="Variables" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="398" />
                      <option name="theoryId" value="5865" />
                      <option name="title" value="Integer arithmetic" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="415" />
                      <option name="theoryId" value="6025" />
                      <option name="title" value="Boolean logic" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="722" />
                      <option name="theoryId" value="8828" />
                      <option name="title" value="Membership testing" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="397" />
                      <option name="theoryId" value="5885" />
                      <option name="title" value="Naming variables" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="404" />
                      <option name="theoryId" value="5913" />
                      <option name="title" value="Taking input" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="399" />
                      <option name="theoryId" value="5872" />
                      <option name="title" value="Program with numbers" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="405" />
                      <option name="theoryId" value="5920" />
                      <option name="title" value="Comparisons" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="406" />
                      <option name="theoryId" value="5953" />
                      <option name="title" value="If statement" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="407" />
                      <option name="theoryId" value="5932" />
                      <option name="title" value="Else statement" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="408" />
                      <option name="theoryId" value="5926" />
                      <option name="title" value="Elif statement" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="2">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="395" />
                      <option name="theoryId" value="5979" />
                      <option name="title" value="List" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="435" />
                      <option name="theoryId" value="6189" />
                      <option name="title" value="Indexes" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="564" />
                      <option name="theoryId" value="7462" />
                      <option name="title" value="Tuple" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="400" />
                      <option name="theoryId" value="5891" />
                      <option name="title" value="Invoking a function" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="401" />
                      <option name="theoryId" value="5900" />
                      <option name="title" value="Declaring a function" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="534" />
                      <option name="theoryId" value="7248" />
                      <option name="title" value="Arguments" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="416" />
                      <option name="theoryId" value="6031" />
                      <option name="title" value="Operations with list" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="414" />
                      <option name="theoryId" value="6019" />
                      <option name="title" value="Load module" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="448" />
                      <option name="theoryId" value="6263" />
                      <option name="title" value="Random module" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="3">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="259" />
                      <option name="theoryId" value="3805" />
                      <option name="title" value="IDE" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="393" />
                      <option name="theoryId" value="5814" />
                      <option name="title" value="Quotes and multi-line strings" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="417" />
                      <option name="theoryId" value="6037" />
                      <option name="title" value="String formatting" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="501" />
                      <option name="theoryId" value="6842" />
                      <option name="title" value="Basic string methods" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="438" />
                      <option name="theoryId" value="6193" />
                      <option name="title" value="PyCharm basics" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="4">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="487" />
                      <option name="theoryId" value="6643" />
                      <option name="title" value="Set" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="429" />
                      <option name="theoryId" value="6065" />
                      <option name="title" value="For loop" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="5">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="409" />
                      <option name="theoryId" value="5940" />
                      <option name="title" value="While loop" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="453" />
                      <option name="theoryId" value="6302" />
                      <option name="title" value="Loop control statements" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
              <entry key="6">
                <value>
                  <list>
                    <HyperskillTopic>
                      <option name="id" value="418" />
                      <option name="theoryId" value="6047" />
                      <option name="title" value="Program execution" />
                    </HyperskillTopic>
                    <HyperskillTopic>
                      <option name="id" value="419" />
                      <option name="theoryId" value="6052" />
                      <option name="title" value="Errors" />
                    </HyperskillTopic>
                  </list>
                </value>
              </entry>
            </map>
          </option>
          <option name="updateDate" value="0" />
          <option name="hyperskillProject">
            <HyperskillProject>
              <option name="description" value="Games can help you kill time when you’re bored. But before smartphones, people played games the classic way – with paper and pencil. Let’s recreate one such game and improve your programming skills in the process. In this project, you will code Hangman, a game where the player has to guess a word, letter by letter, in a limited number of attempts. Make a program that plays Hangman with you – and good luck with the guessing!" />
              <option name="id" value="69" />
              <option name="ideFiles" value="https://stepik.org/media/attachments/lesson/225053/additional_files.json" />
              <option name="language" value="python" />
              <option name="templateBased" value="false" />
              <option name="title" value="Hangman" />
              <option name="useIde" value="true" />
            </HyperskillProject>
          </option>
          <option name="items">
            <list>
              <FrameworkLesson>
                <option name="currentTaskIndex" value="1" />
                <option name="customPresentableName" />
                <option name="id" value="0" />
                <option name="index" value="1" />
                <option name="name" value="Hangman" />
                <option name="updateDate" value="0" />
                <option name="unitId" value="0" />
                <option name="items">
                  <list>
                    <EduTask>
                      <option name="customPresentableName" value="stage1" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;p&gt;&lt;strong&gt;Hangman&lt;/strong&gt; is a popular yet grim intellectual game. A cruel computer hides a word from you. Letter by letter you try to guess it. If you fail, you'll be hanged, if you win, you'll survive. See also: &lt;a target=&quot;_blank&quot; href=&quot;https://en.wikipedia.org/wiki/Hangman_(game)&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;&#10;&#10;&lt;p&gt;You probably played the game at least once in your life; now you can actually create this game yourself!&lt;/p&gt;&#10;&#10;&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Let's have a brief overview of what you are going to build during this project. Here is what the gameplay should look like:&lt;/p&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;In the main menu, a player can choose to either play or exit the game;&lt;/li&gt;&#10;&#9;&lt;li&gt;If the user chooses to play, the computer picks a word from a list: this will be the riddle;&lt;/li&gt;&#10;&#9;&lt;li&gt;The computer asks the player to enter a letter that (s)he thinks is in the word;&lt;/li&gt;&#10;&#9;&lt;li&gt;If there's no such letter in the word and this letter hasn't been tried before, the computer counts it as a miss. A player can afford only up to 8 misses before the game is over;&lt;/li&gt;&#10;&#9;&lt;li&gt;If the letter does occur in the word, the computer notifies the player. If there are letters left to guess, the computer invites the player to go on.&lt;/li&gt;&#10;&#9;&lt;li&gt;When the entire word is uncovered, it's a victory! The game calculates the final score and goes back to the main menu.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;It may sound complex, but the project is split into small stages with hints to see you through. The final product is sure to be replayable and quite engaging!&lt;/p&gt;&#10;&#10;&lt;p&gt;Let's start with an announcement that will greet the player. You already know how to print something using Python: try to apply your knowledge to intrigue your friends with your game announcement!&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;p&gt;In this stage you should &lt;strong&gt;write a program &lt;/strong&gt;that prints the lines as shown in the example below:&lt;/p&gt;&#10;&#10;&lt;h2&gt;Example &lt;/h2&gt;&#10;&#10;&lt;p&gt;Output:&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;The game will be available soon.&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/372/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6082" />
                      <option name="index" value="1" />
                      <option name="name" value="Hello, Hangman" />
                      <option name="record" value="1" />
                      <option name="status" value="Solved" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;&#10;right_str = &quot;&quot;&quot;H A N G M A N&#10;The game will be available soon.&quot;&quot;&quot;&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        return [TestCase(attach=right_str)]&#10;&#10;    def check(self, reply: str, attach: str) -&gt; CheckResult:&#10;        if reply.strip() == attach.strip():&#10;            return CheckResult.correct()&#10;        return CheckResult.wrong(&#10;            &quot;You should print output exactly like in the example&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="true" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="# Write your code here&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" value="stage2" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;At this stage, you will create a real game. It will be simple, but there will be two possible outcomes (you can see in the examples below how they look like). Let's first print a welcome message and then ask a player to guess the word we set for the game. If our player manages to guess the exact word, the game reports &quot;win&quot;; otherwise it will &quot;hang&quot; the player.&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;Ask a player for a possible word.&lt;/li&gt;&#10;&#9;&lt;li&gt;Print &lt;code class=&quot;java&quot;&gt;You survived!&lt;/code&gt; if the user guessed the word.&lt;/li&gt;&#10;&#9;&lt;li&gt;Print &lt;code class=&quot;java&quot;&gt;You are hanged!&lt;/code&gt; if the user haven't guessed the word&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;&lt;div class=&quot;alert alert-primary&quot;&gt;By the way, the word &lt;code class=&quot;java&quot;&gt;python&lt;/code&gt; should be the correct word to win the game.&lt;/div&gt;&lt;/p&gt;&#10;&#10;&lt;h2&gt;Examples&lt;/h2&gt;&#10;&#10;&lt;p&gt;The greater-than symbol followed by space (&lt;code class=&quot;java&quot;&gt;&amp;gt; &lt;/code&gt;) represents the user input. Notice that it's not the part of the input.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: &amp;gt; python&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: &amp;gt; java&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/373/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6083" />
                      <option name="index" value="2" />
                      <option name="name" value="I want to play a game" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        return [&#10;            TestCase(stdin='python', attach=(True, 'python')),&#10;            TestCase(stdin='java', attach=(False, 'java')),&#10;            TestCase(stdin='pyton', attach=(False, '')),&#10;            TestCase(stdin='python', attach=(True, '')),&#10;        ]&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        right_ans, guess = attach&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        if survived in reply and hanged in reply:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.')&#10;&#10;        if survived not in reply and hanged not in reply:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.')&#10;&#10;        if right_ans:&#10;            if survived in reply:&#10;                return CheckResult.correct()&#10;&#10;            if guess:&#10;                return CheckResult.wrong(&#10;                    'input: ' + 'python\n'&#10;                    'correct output: ' + survived&#10;                )&#10;&#10;            else:&#10;                return CheckResult.wrong('')&#10;&#10;        else:&#10;            if hanged in reply:&#10;                return CheckResult.correct()&#10;&#10;            if guess:&#10;                return CheckResult.wrong(&#10;                    'input: ' + 'java\n'&#10;                    'correct output: ' + hanged&#10;                )&#10;&#10;            else:&#10;                return CheckResult.wrong('')&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                          <entry key="hangman/hangman.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="hangman/hangman.py" />
                                <option name="text" value="# Write your code here&#10;print('H A N G M A N')&#10;print('The game will be available soon.')&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="true" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" value="stage3" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;If there is a predefined word, the game isn't replayable: you already know the word, so it makes no sense to guess it. At this stage, let's make the game more challenging by choosing a word from a special list with a variety of options. This way, our game won't be just a one-time entertainment.&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;Create the following word list: &lt;code class=&quot;java&quot;&gt;'python', 'java', 'kotlin', 'javascript'&lt;/code&gt;.&lt;/li&gt;&#10;&#9;&lt;li&gt;Program the game to choose a random word from it. You can enter more words, but let's stick to these four for now.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;h2&gt;Examples&lt;/h2&gt;&#10;&#10;&lt;p&gt;The greater-than symbol followed by space (&lt;code class=&quot;java&quot;&gt;&amp;gt; &lt;/code&gt;) represents the user input. Notice that it's not the part of the input.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1, &lt;/strong&gt;&lt;em&gt; the computer randomly chose &lt;code class=&quot;java&quot;&gt;python&lt;/code&gt; from the list.&lt;/em&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: &amp;gt; python&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2, &lt;/strong&gt;&lt;em&gt;the computer randomly chose something other than &lt;code class=&quot;java&quot;&gt;python&lt;/code&gt; from the list.&lt;/em&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: &amp;gt; python&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 3, &lt;/strong&gt;&lt;em&gt;the computer randomly chose something other than &lt;code class=&quot;java&quot;&gt;kotlin&lt;/code&gt; from the list.&lt;/em&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word: &amp;gt; kotlin&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/374/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6084" />
                      <option name="index" value="3" />
                      <option name="name" value="Make your choice" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;&#10;from random import shuffle&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description:&#10;            for i in range(100):&#10;                tests += [TestCase(stdin=word, attach=word)]&#10;&#10;        shuffle(tests)&#10;&#10;        word = 'last'&#10;        tests += [TestCase(stdin=word, attach=word)]&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in reply&#10;        is_hanged = hanged in reply&#10;&#10;        if is_survived and is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if attach in out_of_description:&#10;            if is_survived:&#10;                return CheckResult.wrong(&#10;                    f'Input contains a word out of the '&#10;                    f'list form the description but the '&#10;                    f'program output \&quot;{survived}\&quot;'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;        elif attach in description_list:&#10;            catch[attach] += is_survived&#10;            return CheckResult.correct()&#10;&#10;        else:&#10;            if any(v == 0 for v in catch.values()):&#10;                return CheckResult.wrong(&#10;                    &quot;Looks like your program is not using &quot;&#10;                    &quot;all of the words to guess from the list in description&quot;&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" value="stage4" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now our game has become quite hard, and your chances of guessing the word depend on the size of the list. In our case with four words, there is only a 25% chance, so let's have mercy on the player and add a hint for them.&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;As in the previous stage, you should use the following word list: &lt;code class=&quot;java&quot;&gt;'python', 'java', 'kotlin', 'javascript'&lt;/code&gt;&lt;/li&gt;&#10;&#9;&lt;li&gt;Show the &lt;strong&gt;first 3 letters&lt;/strong&gt; after the computer chose a word from the list. Hidden letters should be replaced with hyphens (&lt;code class=&quot;java&quot;&gt;&quot;-&quot;&lt;/code&gt;).&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;h2&gt;Examples&lt;/h2&gt;&#10;&#10;&lt;p&gt;The greater-than symbol followed by space (&lt;code class=&quot;java&quot;&gt;&amp;gt; &lt;/code&gt;) represents the user input. Notice that it's not the part of the input.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word jav-: &amp;gt; java&#10;You survived!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Guess the word pyt---: &amp;gt; pythia&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/375/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6085" />
                      <option name="index" value="4" />
                      <option name="name" value="Help is on the way" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;&#10;from random import shuffle&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description:&#10;            for i in range(100):&#10;                tests += [TestCase(stdin=word, attach=word)]&#10;&#10;        shuffle(tests)&#10;&#10;        word = 'last'&#10;        tests += [TestCase(stdin=word, attach=word)]&#10;        return tests&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in reply&#10;        is_hanged = hanged in reply&#10;&#10;        if is_survived and is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if attach in out_of_description:&#10;            if is_survived:&#10;                return CheckResult.wrong(&#10;                    f'Input contains a word out of the '&#10;                    f'list form the description but the '&#10;                    f'program output \&quot;{survived}\&quot;'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;        elif attach in description_list:&#10;&#10;            if is_survived:&#10;                hidden_attach = attach[:3] + '-'*len(attach[3:])&#10;                if hidden_attach not in reply:&#10;                    return CheckResult.wrong(&#10;                        f'Program guessed the word \&quot;{attach}\&quot; '&#10;                        f'and should output clue \&quot;{hidden_attach}\&quot; '&#10;                        f'but this line is not in the output'&#10;                    )&#10;&#10;            catch[attach] += is_survived&#10;            return CheckResult.correct()&#10;&#10;        else:&#10;            if any(v == 0 for v in catch.values()):&#10;                return CheckResult.wrong(&#10;                    &quot;Looks like your program is not using &quot;&#10;                    &quot;all of the words to guess from the list in description&quot;&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" value="stage5" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Let's make the game iterative. It's time to make it resemble the classical Hangman a bit more: a player should guess letters in the word instead of typing the entire word at once. If the player guesses a letter, it should be uncovered in the word. For now, start with the defeat case and add 8 tries to guess a letter that appears in the word. When the player runs out of attempts, the game ends.&lt;/p&gt;&#10;&#10;&lt;p&gt;Later we will determine the winning conditions, but in this stage, let's see how well our player guesses the word on every attempt.&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now your game should work the following way:&lt;/p&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;A player has &lt;strong&gt;exactly 8 tries&lt;/strong&gt; and enters letters. If a player has more tries but he actually guessed the word, it doesn't mean anything.&lt;/li&gt;&#10;&#9;&lt;li&gt;If the letter doesn't occur in the word, the computer takes one try away, even if the user already inputted this letter before.&lt;/li&gt;&#10;&#9;&lt;li&gt;If the player doesn't have any more attempts, the game should end and the program should show a losing message. Otherwise, the player can continue to input letters.&lt;/li&gt;&#10;&#9;&lt;li&gt;Also, use our  previous word list: &lt;code class=&quot;java&quot;&gt;'python', 'java', 'kotlin', 'javascript'&lt;/code&gt; so that your program can be tested more reliably.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;&lt;div class=&quot;alert alert-warning&quot;&gt;Please, make sure that your program's output formatting precisely follows the example output formatting. Pay attention to the empty lines between tries and in the end.&lt;/div&gt;&lt;/p&gt;&#10;&#10;&lt;h2&gt;Examples&lt;/h2&gt;&#10;&#10;&lt;p&gt;The greater-than symbol followed by space (&lt;code class=&quot;java&quot;&gt;&amp;gt; &lt;/code&gt;) represents the user input. Notice that it's not the part of the input.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----------&#10;Input a letter: &amp;gt; a&#10;&#10;-a-a------&#10;Input a letter: &amp;gt; i&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; z&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; p&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; p&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; h&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; k&#10;No such letter in the word&#10;&#10;Thanks for playing!&#10;We'll see how well you did in the next stage&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----&#10;Input a letter: &amp;gt; j&#10;&#10;j---&#10;Input a letter: &amp;gt; i&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; o&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; a&#10;&#10;ja-a&#10;Input a letter: &amp;gt; v&#10;&#10;java&#10;Input a letter: &amp;gt; a&#10;&#10;java&#10;Input a letter: &amp;gt; j&#10;&#10;Thanks for playing!&#10;We'll see how well you did in the next stage&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/376/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6086" />
                      <option name="index" value="5" />
                      <option name="name" value="Keep trying" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;&#10;from random import shuffle&#10;from string import ascii_lowercase&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w for w in word * 2]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;&#10;        word = 'l\na\ns\nt\n' * 2&#10;        tests += [TestCase(stdin=word, attach='last')]&#10;        return tests&#10;&#10;    # in old tests there was a \n after 'Input a letter:' return it!&#10;    def _fix_reply(self, reply: str):&#10;        pos = 0&#10;        phrases = []&#10;        while True:&#10;            pos1 = reply.find(&quot;letter:&quot;, pos)&#10;            if pos1 == -1:&#10;                phrases.append(reply[pos:].strip(' '))&#10;                break&#10;            pos1 += len(&quot;letter:&quot;)&#10;            phrases.append(reply[pos:pos1].strip(' '))&#10;            pos = pos1&#10;        return '\n'.join(phrases)&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        reply = self._fix_reply(reply)&#10;        tries = [i.strip() for i in reply.strip().split('\n\n') if len(i.strip())]&#10;&#10;        if len(tries) == 0:&#10;            return CheckResult.wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        if &quot;Input a letter&quot; not in reply:&#10;            return CheckResult.wrong(&#10;                &quot;Input doesn't contain any \&quot;Input a letter\&quot; lines&quot;&#10;            )&#10;&#10;        if 'for playing' not in tries[-1]:&#10;            return CheckResult.wrong(&#10;                &quot;Last block should contain text \&quot;Thanks for playing!\&quot;&quot;&#10;            )&#10;&#10;        elif &quot;Input a letter&quot; in tries[-1]:&#10;            return CheckResult.wrong(&#10;                &quot;Last block should not contain text \&quot;Input a letter\&quot;&quot;&#10;            )&#10;&#10;        tries = tries[:-1]&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return CheckResult.wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        if len(blocks) &lt; 8:&#10;            return CheckResult.wrong(&#10;                f'There are less than 8 blocks of output. '&#10;                f'Did you separate each guess attempt with a new line?'&#10;            )&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return CheckResult.wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-' * len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return CheckResult.wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        for letter, prev, next in zip(attach, blocks[0:], blocks[1:]):&#10;&#10;            cond1 = (&#10;                    (letter not in prev) and&#10;                    (letter in next) and&#10;                    (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                    (letter not in prev) and&#10;                    (letter not in next) and&#10;                    (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                    (letter in prev) and&#10;                    (letter in next) and&#10;                    (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return CheckResult.wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if '-' not in blocks[-1]:&#10;            catch[blocks[-1]] += 1&#10;&#10;        if attach == 'last':&#10;            if catch.values() == 0:&#10;                return CheckResult.wrong(&#10;                    &quot;Looks like your program is not using &quot;&#10;                    &quot;all of the words to guess from the list in description&quot;&#10;                )&#10;&#10;        return CheckResult.correct()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" value="stage6" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;The recent version of the game is not as fun until we don't handle the player's victory. A player has 8 attempts to guess letters and its number is reduced even if the letter was correct.&lt;/p&gt;&#10;&#10;&lt;p&gt;Now a player will have a lot of attempts and is limited only by the number of mistakes they make. A player can be mistaken 8 times and wins when &lt;strong&gt;all&lt;/strong&gt; the letters are guessed and there are still some tries left. If the player uses the last try and actually guesses the word, they are lucky then!&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;p&gt;The player starts the game with 8 &quot;lives&quot;, that is our player can input the wrong letter 8 times.&lt;/p&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;Print &lt;code class=&quot;java&quot;&gt;No such letter in the word&lt;/code&gt; and reduce the attempts count if the word guessed by the program doesn't contain this letter.&lt;/li&gt;&#10;&#9;&lt;li&gt;Print &lt;code class=&quot;java&quot;&gt;No improvements&lt;/code&gt; and reduce the attempts count if the guessed word contains this letter but the user tried this letter before.&lt;/li&gt;&#10;&#9;&lt;li&gt;The attempts count should be decreased &lt;strong&gt;only&lt;/strong&gt; if there are no letters to uncover.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;&lt;div class=&quot;alert alert-warning&quot;&gt;Please, make sure that your program's output formatting precisely follows the example output formatting. Pay attention to the empty lines between tries and in the end.&lt;/div&gt;&lt;/p&gt;&#10;&#10;&lt;h2&gt;Examples&lt;/h2&gt;&#10;&#10;&lt;p&gt;The greater-than symbol followed by space (&lt;code class=&quot;java&quot;&gt;&amp;gt; &lt;/code&gt;) represents the user input. Notice that it's not the part of the input.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;------&#10;Input a letter: &amp;gt; t&#10;&#10;--t---&#10;Input a letter: &amp;gt; z&#10;No such letter in the word&#10;&#10;--t---&#10;Input a letter: &amp;gt; t&#10;No improvements&#10;&#10;--t---&#10;Input a letter: &amp;gt; t&#10;No improvements&#10;&#10;--t---&#10;Input a letter: &amp;gt; y&#10;&#10;-yt---&#10;Input a letter: &amp;gt; x&#10;No such letter in the word&#10;&#10;-yt---&#10;Input a letter: &amp;gt; y&#10;No improvements&#10;&#10;-yt---&#10;Input a letter: &amp;gt; p&#10;&#10;pyt---&#10;Input a letter: &amp;gt; p&#10;No improvements&#10;&#10;pyt---&#10;Input a letter: &amp;gt; q&#10;No such letter in the word&#10;&#10;pyt---&#10;Input a letter: &amp;gt; p&#10;No improvements&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----&#10;Input a letter: &amp;gt; j&#10;&#10;j---&#10;Input a letter: &amp;gt; i&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; a&#10;&#10;ja-a&#10;Input a letter: &amp;gt; v&#10;&#10;java&#10;You guessed the word!&#10;You survived!&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/377/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6087" />
                      <option name="index" value="6" />
                      <option name="name" value="The value of life" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;&#10;from random import shuffle&#10;from string import ascii_lowercase&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w for w in word * 30]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;        return tests&#10;&#10;    # in old tests there was a \n after 'Input a letter:' return it!&#10;    def _fix_reply(self, reply: str):&#10;        pos = 0&#10;        phrases = []&#10;        while True:&#10;            pos1 = reply.find(&quot;letter:&quot;, pos)&#10;            if pos1 == -1:&#10;                phrases.append(reply[pos:].strip(' '))&#10;                break&#10;            pos1 += len(&quot;letter:&quot;)&#10;            phrases.append(reply[pos:pos1].strip(' '))&#10;            pos = pos1&#10;        return '\n'.join(phrases)&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        reply = self._fix_reply(reply)&#10;        tries = [i.strip() for i in reply.split('\n\n') if len(i.strip())]&#10;&#10;        if len(tries) == 0:&#10;            return CheckResult.wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return CheckResult.wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in full_blocks[-1]&#10;        is_hanged = hanged in full_blocks[-1]&#10;&#10;        no_such_letter = 'No such letter in the word'&#10;        no_improvements = 'No improvements'&#10;&#10;        if is_hanged:&#10;            if (no_such_letter not in full_blocks[-1] and&#10;                    no_improvements not in full_blocks[-1]):&#10;&#10;                return CheckResult.wrong(&#10;                    f'Last block contains &quot;{hanged}&quot; '&#10;                    f'but doesn\'t contain &quot;{no_improvements}&quot; or '&#10;                    f'&quot;{no_such_letter}&quot;. Check the first example. These texts '&#10;                    f'should be within the same block. Your last block:\n\n'&#10;                    f'{full_blocks[-1]}'&#10;                )&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return CheckResult.wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-'*len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return CheckResult.wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        wrong_count = 0&#10;&#10;        if is_hanged:&#10;            blocks += [blocks[-1]]&#10;            full_blocks += [full_blocks[-1]]&#10;&#10;        for letter, prev, next, prev_full, next_full in zip(&#10;                attach, blocks[0:], blocks[1:], full_blocks[0:], full_blocks[1:]):&#10;&#10;            if prev == next:&#10;                wrong_count += 1&#10;&#10;            detect_no_such_letter = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next == prev)&#10;            )&#10;&#10;            if detect_no_such_letter and no_such_letter not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_such_letter}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_such_letter and no_such_letter in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_such_letter}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            detect_no_improvements = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next == prev)&#10;            )&#10;&#10;            if detect_no_improvements and no_improvements not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_improvements}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_improvements and no_improvements in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_improvements}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            cond1 = (&#10;                (letter not in prev) and&#10;                (letter in next) and&#10;                (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return CheckResult.wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if is_survived and is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if is_hanged:&#10;            if wrong_count != 8:&#10;                return CheckResult.wrong(&#10;                    f'User was hanged after {wrong_count} wrong guesses, but should after 8. '&#10;                    f'Notice, that in this stage &quot;No improvements&quot; also counts as wrong guess.'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;        if is_survived:&#10;            if wrong_count &gt;= 8:&#10;                return CheckResult.wrong(&#10;                    f'User survived but have {wrong_count} wrong guesses. He should be hanged'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" value="stage7" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;Now that we are done with the basics, let's work on some details.&lt;/p&gt;&#10;&#10;&lt;p&gt;In the previous stage if the user entered the same letter twice or typed a cyrillic letter, the program reduced the number of attempts regardless if this was a correct letter or not. But it is not fair to the user, isn't it? He gains no additional information about the situation on the field yet the program still reduces his attempts count. Let's fix it!&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;If the user enters the same letter twice then the program should output &lt;code class=&quot;java&quot;&gt;You already typed this letter&lt;/code&gt; .&lt;/li&gt;&#10;&#9;&lt;li&gt;Also, you should check if the user prints an English lowercase letter or not. If not, the program should print &lt;code class=&quot;java&quot;&gt;It is not an ASCII lowercase letter&lt;/code&gt; . &lt;/li&gt;&#10;&#9;&lt;li&gt;Also, you should check if the user printed exactly one letter. If not, the program should print &lt;code class=&quot;java&quot;&gt;You should print a single letter&lt;/code&gt; . Remember that zero is also not one!&lt;/li&gt;&#10;&#9;&lt;li&gt;Note that all these three errors should not reduce attempts count!&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;&lt;div class=&quot;alert alert-warning&quot;&gt;Please, make sure that your program's output formatting precisely follows the example output formatting. Pay attention to the empty lines between tries and in the end.&lt;/div&gt;&lt;/p&gt;&#10;&#10;&lt;h2&gt;Examples&lt;/h2&gt;&#10;&#10;&lt;p&gt;The greater-than symbol followed by space (&lt;code class=&quot;java&quot;&gt;&amp;gt; &lt;/code&gt;) represents the user input. Notice that it's not the part of the input.&lt;/p&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----------&#10;Input a letter: &amp;gt; a&#10;&#10;-a-a------&#10;Input a letter: &amp;gt; i&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; o&#10;You already typed this letter&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; p&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; p&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; h&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; k&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; a&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; z&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; t&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; x&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; b&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; d&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; w&#10;No such letter in the word&#10;You are hanged!&lt;/code&gt;&lt;/pre&gt;&#10;&#10;&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;&#10;----&#10;Input a letter: &amp;gt; j&#10;&#10;j---&#10;Input a letter: &amp;gt; i&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; +&#10;It is not an ASCII lowercase letter&#10;&#10;j---&#10;Input a letter: &amp;gt; A&#10;It is not an ASCII lowercase letter&#10;&#10;j---&#10;Input a letter: &amp;gt; ii&#10;You should print a single letter&#10;&#10;j---&#10;Input a letter: &amp;gt; ++&#10;You should print a single letter&#10;&#10;j---&#10;Input a letter: &amp;gt;&#10;You should print a single letter&#10;&#10;j---&#10;Input a letter: &amp;gt; g&#10;No such letter in the word&#10;&#10;j---&#10;Input a letter: &amp;gt; a&#10;&#10;ja-a&#10;Input a letter: &amp;gt; v&#10;You guessed the word java!&#10;You survived!&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/378/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6088" />
                      <option name="index" value="7" />
                      <option name="name" value="Error!" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;&#10;from random import shuffle, randint&#10;from string import ascii_lowercase, ascii_letters, punctuation, digits&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;all_letters = ascii_letters + punctuation + digits&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w if randint(1, 100) &lt; 95 else w + w for w in word * 50 + all_letters]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;        return tests&#10;&#10;    # in old tests there was a \n after 'Input a letter:' return it!&#10;    def _fix_reply(self, reply: str):&#10;        pos = 0&#10;        phrases = []&#10;        while True:&#10;            pos1 = reply.find(&quot;letter:&quot;, pos)&#10;            if pos1 == -1:&#10;                phrases.append(reply[pos:].strip(' '))&#10;                break&#10;            pos1 += len(&quot;letter:&quot;)&#10;            phrases.append(reply[pos:pos1].strip(' '))&#10;            pos = pos1&#10;        return '\n'.join(phrases)&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        reply = self._fix_reply(reply)&#10;        tries = [i.strip() for i in reply.split('\n\n') if len(i.strip())]&#10;&#10;        if len(tries) == 0:&#10;            return CheckResult.wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return CheckResult.wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in full_blocks[-1]&#10;        is_hanged = hanged in full_blocks[-1]&#10;&#10;        no_such_letter = 'No such letter in the word'&#10;        already_typed = 'You already typed this letter'&#10;        not_ascii = 'It is not an ASCII lowercase letter'&#10;        print_single = 'You should print a single letter'&#10;&#10;        if is_hanged:&#10;            if (no_such_letter not in full_blocks[-1]):&#10;                return CheckResult.wrong(&#10;                    f'Last block contains &quot;{hanged}&quot; '&#10;                    f'but doesn\'t contain &quot;{no_such_letter}&quot;. '&#10;                    f'Check the first example. These texts '&#10;                    f'should be within the same block. Your last block:\n\n'&#10;                    f'{full_blocks[-1]}'&#10;                )&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return CheckResult.wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-'*len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return CheckResult.wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        wrong_count = 0&#10;        typed_letters = set()&#10;        inputs = ''&#10;&#10;        if is_hanged:&#10;            blocks += [blocks[-1]]&#10;            full_blocks += [full_blocks[-1]]&#10;&#10;        for letter, prev, next, prev_full, next_full in zip(&#10;                attach, blocks[0:], blocks[1:], full_blocks[0:], full_blocks[1:]):&#10;&#10;            # ---&#10;            detect_not_one = len(letter) != 1&#10;&#10;            if detect_not_one and print_single not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{print_single}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_one and print_single in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{print_single}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_one:&#10;                continue&#10;&#10;            # ---&#10;            detect_not_ascii = letter not in ascii_lowercase&#10;&#10;            if detect_not_ascii and not_ascii not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{not_ascii}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_ascii and not_ascii in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{not_ascii}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_ascii:&#10;                continue&#10;&#10;            inputs += '\n' + letter&#10;&#10;            # ---&#10;            detect_typed_letter = letter in typed_letters&#10;&#10;            if detect_typed_letter and already_typed not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{already_typed}\&quot; message, but should be\n'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;            elif not detect_typed_letter and already_typed in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{already_typed}\&quot; message, but shouldn\'t be'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;&#10;            if detect_typed_letter:&#10;                continue&#10;&#10;            # ---&#10;            detect_no_such_letter = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next == prev) and not detect_typed_letter&#10;            )&#10;&#10;            if detect_no_such_letter and no_such_letter not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_such_letter}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_such_letter and no_such_letter in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_such_letter}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_no_such_letter:&#10;                wrong_count += 1&#10;&#10;            typed_letters |= {letter}&#10;&#10;            cond1 = (&#10;                (letter not in prev) and&#10;                (letter in next) and&#10;                (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return CheckResult.wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if is_survived and is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if is_hanged:&#10;            if wrong_count != 8:&#10;                return CheckResult.wrong(&#10;                    f'User was hanged after {wrong_count} wrong guesses, but should after 8'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;        if is_survived:&#10;            if wrong_count &gt;= 8:&#10;                return CheckResult.wrong(&#10;                    f'User survived but have {wrong_count} wrong guesses. He should be hanged'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                    <EduTask>
                      <option name="customPresentableName" value="stage8" />
                      <option name="descriptionFormat" value="HTML" />
                      <option name="descriptionText" value="&lt;h2&gt;Description&lt;/h2&gt;&#10;&#10;&lt;p&gt;We're almost done!&lt;/p&gt;&#10;&#10;&lt;p&gt;Let's add more flavor to the game by adding a suggestion to replay after the current game session ends.&lt;/p&gt;&#10;&#10;&lt;h2&gt;Objectives&lt;/h2&gt;&#10;&#10;&lt;ol&gt;&#10;&#9;&lt;li&gt;The game starts with a menu where a player can choose to either play or exit.&lt;/li&gt;&#10;&#9;&lt;li&gt;Print &lt;code class=&quot;java&quot;&gt;Type &quot;play&quot; to play the game, &quot;exit&quot; to quit:&lt;/code&gt; and ask again if the player inputs something else.&lt;/li&gt;&#10;&#9;&lt;li&gt;If the user chooses to play, the game starts.&lt;/li&gt;&#10;&lt;/ol&gt;&#10;&#10;&lt;p&gt;&lt;div class=&quot;alert alert-warning&quot;&gt;Please, make sure that your program's output formatting precisely follows the example output formatting. Pay attention to the empty lines between tries and in the end.&lt;/div&gt;&lt;/p&gt;&#10;&#10;&lt;h2&gt;Example&lt;/h2&gt;&#10;&#10;&lt;p&gt;The greater-than symbol followed by space (&lt;code class=&quot;java&quot;&gt;&amp;gt; &lt;/code&gt;) represents the user input. Notice that it's not the part of the input.&lt;/p&gt;&#10;&#10;&lt;pre&gt;&lt;code class=&quot;language-no-highlight&quot;&gt;H A N G M A N&#10;Type &quot;play&quot; to play the game, &quot;exit&quot; to quit: &amp;gt; play&#10;&#10;----------&#10;Input a letter: &amp;gt; a&#10;&#10;-a-a------&#10;Input a letter: &amp;gt; i&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; o&#10;No such letter in the word&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; o&#10;You already typed this letter&#10;&#10;-a-a---i--&#10;Input a letter: &amp;gt; p&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; p&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; h&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; k&#10;No such letter in the word&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; a&#10;You already typed this letter&#10;&#10;-a-a---ip-&#10;Input a letter: &amp;gt; z&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; t&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; x&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; b&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; d&#10;No such letter in the word&#10;&#10;-a-a---ipt&#10;Input a letter: &amp;gt; w&#10;No such letter in the word&#10;You are hanged!&#10;&#10;Type &quot;play&quot; to play the game, &quot;exit&quot; to quit: &amp;gt; exit&lt;/code&gt;&lt;/pre&gt;" />
                      <option name="feedbackLink">
                        <FeedbackLink>
                          <option name="link" value="https://hyperskill.org/projects/69/stages/379/implement" />
                          <option name="type" value="CUSTOM" />
                        </FeedbackLink>
                      </option>
                      <option name="id" value="6089" />
                      <option name="index" value="8" />
                      <option name="name" value="Menu, please" />
                      <option name="record" value="-1" />
                      <option name="status" value="Unchecked" />
                      <option name="files">
                        <map>
                          <entry key="tests.py">
                            <value>
                              <TaskFile>
                                <option name="answerPlaceholders">
                                  <list />
                                </option>
                                <option name="highlightErrors" value="false" />
                                <option name="name" value="tests.py" />
                                <option name="text" value="from hstest.stage_test import *&#10;from hstest.test_case import TestCase&#10;from hstest.check_result import CheckResult&#10;&#10;from random import shuffle, randint&#10;from string import ascii_lowercase, ascii_letters, punctuation, digits&#10;&#10;CheckResult.correct = lambda: CheckResult(True, '')&#10;CheckResult.wrong = lambda feedback: CheckResult(False, feedback)&#10;&#10;description_list = ['python', 'java', 'kotlin', 'javascript']&#10;out_of_description = ['clojure', 'haskell', 'typescript', 'assembler']&#10;&#10;catch = {i: 0 for i in description_list}&#10;all_letters = ascii_letters + punctuation + digits&#10;&#10;&#10;class CoffeeMachineTest(StageTest):&#10;    def generate(self) -&gt; List[TestCase]:&#10;        tests = []&#10;&#10;        for word in description_list + out_of_description + [ascii_lowercase]:&#10;            for i in range(100):&#10;                words = [w if randint(1, 100) &lt; 95 else w + w for w in word * 50 + all_letters]&#10;                shuffle(words)&#10;                inputs = '\n'.join(words)&#10;                inputs = 'play\n' + inputs + '\nexit'&#10;                tests += [TestCase(stdin=inputs, attach=words)]&#10;&#10;        shuffle(tests)&#10;        return tests&#10;&#10;    # in old tests there was a \n after 'Input a letter:' return it!&#10;    def _fix_reply(self, reply: str):&#10;        pos = 0&#10;        phrases = []&#10;        while True:&#10;            pos1 = reply.find(&quot;:&quot;, pos)&#10;            if pos1 == -1:&#10;                phrases.append(reply[pos:].strip(' '))&#10;                break&#10;            pos1 += len(&quot;:&quot;)&#10;            phrases.append(reply[pos:pos1].strip(' '))&#10;            pos = pos1&#10;        return '\n'.join(phrases)&#10;&#10;    def check(self, reply: str, attach: Any) -&gt; CheckResult:&#10;        reply = self._fix_reply(reply)&#10;        lines = reply.splitlines()&#10;        useful_lines = [i for i in reply.splitlines() if not (&quot;play&quot; in i and &quot;exit&quot; in i)]&#10;&#10;        if len(lines) == len(useful_lines):&#10;            return CheckResult.wrong(&#10;                'Your output should contain at least such line, found 0: \n'&#10;                '\'Type &quot;play&quot; to play the game, &quot;exit&quot; to quit: \''&#10;            )&#10;&#10;        reply = '\n'.join(useful_lines)&#10;&#10;        tries = [i.strip() for i in reply.split('\n\n') if len(i.strip())][1:]&#10;&#10;        if len(tries) == 0:&#10;            return CheckResult.wrong(&#10;                &quot;Seems like you didn't print the game or not separated output properly&quot;&#10;                &quot;(there need to be an empty line between guessing attempts)&quot;&#10;            )&#10;&#10;        full_blocks = [try_ for try_ in tries if len(try_.splitlines()) &gt; 1]&#10;        blocks = [block.splitlines()[0].strip() for block in full_blocks]&#10;&#10;        for full_block, block in zip(full_blocks, blocks):&#10;            if ' ' in block:&#10;                return CheckResult.wrong(&#10;                    'Cannot parse this block - it contains spaces '&#10;                    'in the first line, but shouldn\'t\n\n'&#10;                    f'{full_block}'&#10;                )&#10;&#10;        survived = 'You survived!'&#10;        hanged = 'You are hanged!'&#10;&#10;        is_survived = survived in full_blocks[-1]&#10;        is_hanged = hanged in full_blocks[-1]&#10;&#10;        no_such_letter = 'No such letter in the word'&#10;        already_typed = 'You already typed this letter'&#10;        not_ascii = 'It is not an ASCII lowercase letter'&#10;        print_single = 'You should print a single letter'&#10;&#10;        if is_hanged:&#10;            if (no_such_letter not in full_blocks[-1]):&#10;                return CheckResult.wrong(&#10;                    f'Last block contains &quot;{hanged}&quot; '&#10;                    f'but doesn\'t contain &quot;{no_such_letter}&quot;. '&#10;                    f'Check the first example. These texts '&#10;                    f'should be within the same block. Your last block:\n\n'&#10;                    f'{full_blocks[-1]}'&#10;                )&#10;&#10;        lengths = set(len(i) for i in blocks)&#10;&#10;        str_lengths = []&#10;        for i, curr_len in enumerate(lengths, 1):&#10;            for curr_block in blocks:&#10;                if curr_len == len(curr_block):&#10;                    str_lengths += [f'{i}. {curr_block}']&#10;                    break&#10;&#10;        str_lengths = '\n'.join(str_lengths)&#10;&#10;        if len(lengths) &gt; 1:&#10;            return CheckResult.wrong(&#10;                f'Every line with guessed letters should be the same length as others.\n'&#10;                f'Found lines with guessed letters:\n{str_lengths}'&#10;            )&#10;&#10;        correct = '-'*len(blocks[0])&#10;&#10;        if blocks[0] != correct:&#10;            return CheckResult.wrong(&#10;                f'The first guess should only contain dashes: \n'&#10;                f'{correct}\n'&#10;                f'Your first guess:\n'&#10;                f'{blocks[0]}'&#10;            )&#10;&#10;        wrong_count = 0&#10;        typed_letters = set()&#10;        inputs = ''&#10;&#10;        if is_hanged:&#10;            blocks += [blocks[-1]]&#10;            full_blocks += [full_blocks[-1]]&#10;&#10;        for letter, prev, next, prev_full, next_full in zip(&#10;                attach, blocks[0:], blocks[1:], full_blocks[0:], full_blocks[1:]):&#10;&#10;            # ---&#10;            detect_not_one = len(letter) != 1&#10;&#10;            if detect_not_one and print_single not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{print_single}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_one and print_single in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{print_single}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_one:&#10;                continue&#10;&#10;            # ---&#10;            detect_not_ascii = letter not in ascii_lowercase&#10;&#10;            if detect_not_ascii and not_ascii not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{not_ascii}\&quot; message, but should be'&#10;                )&#10;            elif not detect_not_ascii and not_ascii in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{not_ascii}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_not_ascii:&#10;                continue&#10;&#10;            inputs += '\n' + letter&#10;&#10;            # ---&#10;            detect_typed_letter = letter in typed_letters&#10;&#10;            if detect_typed_letter and already_typed not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{already_typed}\&quot; message, but should be\n'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;            elif not detect_typed_letter and already_typed in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{already_typed}\&quot; message, but shouldn\'t be'&#10;                    f'Input letters: {inputs}'&#10;                )&#10;&#10;            if detect_typed_letter:&#10;                continue&#10;&#10;            # ---&#10;            detect_no_such_letter = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next == prev) and not detect_typed_letter&#10;            )&#10;&#10;            if detect_no_such_letter and no_such_letter not in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is no \&quot;{no_such_letter}\&quot; message, but should be'&#10;                )&#10;            elif not detect_no_such_letter and no_such_letter in prev_full:&#10;                return CheckResult.wrong(&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}\n\n'&#10;                    f'There is \&quot;{no_such_letter}\&quot; message, but shouldn\'t be'&#10;                )&#10;&#10;            if detect_no_such_letter:&#10;                wrong_count += 1&#10;&#10;            typed_letters |= {letter}&#10;&#10;            cond1 = (&#10;                (letter not in prev) and&#10;                (letter in next) and&#10;                (set(next) - set(prev) != set(letter))&#10;            )&#10;&#10;            cond2 = (&#10;                (letter not in prev) and&#10;                (letter not in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            cond3 = (&#10;                (letter in prev) and&#10;                (letter in next) and&#10;                (next != prev)&#10;            )&#10;&#10;            if cond1 or cond2 or cond3:&#10;                return CheckResult.wrong(&#10;                    f'This transition is incorrect:\n'&#10;                    f'Before: {prev}\n'&#10;                    f'Letter: {letter}\n'&#10;                    f'After : {next}'&#10;                )&#10;&#10;        if is_survived and is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output contains both \&quot;{survived}\&quot;'&#10;                f' and \&quot;{hanged}\&quot;. You should output only one of them.'&#10;            )&#10;&#10;        if not is_survived and not is_hanged:&#10;            return CheckResult.wrong(&#10;                f'Looks like your output doesn\'t contain neither \&quot;{survived}\&quot;'&#10;                f' nor \&quot;{hanged}\&quot;. You should output one of them.'&#10;            )&#10;&#10;        if is_hanged:&#10;            if wrong_count != 8:&#10;                return CheckResult.wrong(&#10;                    f'User was hanged after {wrong_count} wrong guesses, but should after 8'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;        if is_survived:&#10;            if wrong_count &gt;= 8:&#10;                return CheckResult.wrong(&#10;                    f'User survived but have {wrong_count} wrong guesses. He should be hanged'&#10;                )&#10;            else:&#10;                return CheckResult.correct()&#10;&#10;&#10;if __name__ == '__main__':&#10;    CoffeeMachineTest('hangman.hangman').run_tests()&#10;" />
                                <option name="trackChanges" value="true" />
                                <option name="visible" value="false" />
                              </TaskFile>
                            </value>
                          </entry>
                        </map>
                      </option>
                      <option name="updateDate" />
                    </EduTask>
                  </list>
                </option>
              </FrameworkLesson>
            </list>
          </option>
        </HyperskillCourse>
      </option>
    </StudyTaskManager>
  </component>
</project>